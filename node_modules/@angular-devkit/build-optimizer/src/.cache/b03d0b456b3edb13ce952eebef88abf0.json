{"remainingRequest":"/data/www/ffbe-chain/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/data/www/ffbe-chain/node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-service.js","dependencies":[{"path":"/data/www/ffbe-chain/node_modules/@ng-bootstrap/ng-bootstrap/datepicker/datepicker-service.js","mtime":1529481784261},{"path":"/data/www/ffbe-chain/node_modules/cache-loader/dist/cjs.js","mtime":1529481786296},{"path":"/data/www/ffbe-chain/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1529481776533}],"contextDependencies":[],"result":["import { NgbCalendar } from './ngb-calendar';\nimport { NgbDate } from './ngb-date';\nimport { Injectable } from '@angular/core';\nimport { isInteger, toInteger } from '../util/util';\nimport { Subject } from 'rxjs/Subject';\nimport { buildMonths, checkDateInRange, checkMinBeforeMax, isChangedDate, isDateSelectable, generateSelectBoxYears, generateSelectBoxMonths, prevMonthDisabled, nextMonthDisabled } from './datepicker-tools';\nimport { filter } from 'rxjs/operator/filter';\nvar NgbDatepickerService = /*@__PURE__*/ (function () {\n    function NgbDatepickerService(_calendar) {\n        this._calendar = _calendar;\n        this._model$ = new Subject();\n        this._select$ = new Subject();\n        this._state = {\n            disabled: false,\n            displayMonths: 1,\n            firstDayOfWeek: 1,\n            focusVisible: false,\n            months: [],\n            navigation: 'select',\n            prevDisabled: false,\n            nextDisabled: false,\n            selectBoxes: { years: [], months: [] },\n            selectedDate: null\n        };\n    }\n    Object.defineProperty(NgbDatepickerService.prototype, \"model$\", {\n        get: function () {\n            return filter.call(this._model$.asObservable(), function (model) { return model.months.length > 0; });\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"select$\", {\n        get: function () { return filter.call(this._select$.asObservable(), function (date) { return date !== null; }); },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"disabled\", {\n        set: function (disabled) {\n            if (this._state.disabled !== disabled) {\n                this._nextState({ disabled: disabled });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"displayMonths\", {\n        set: function (displayMonths) {\n            displayMonths = toInteger(displayMonths);\n            if (isInteger(displayMonths) && displayMonths > 0 && this._state.displayMonths !== displayMonths) {\n                this._nextState({ displayMonths: displayMonths });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"firstDayOfWeek\", {\n        set: function (firstDayOfWeek) {\n            firstDayOfWeek = toInteger(firstDayOfWeek);\n            if (isInteger(firstDayOfWeek) && firstDayOfWeek >= 0 && this._state.firstDayOfWeek !== firstDayOfWeek) {\n                this._nextState({ firstDayOfWeek: firstDayOfWeek });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"focusVisible\", {\n        set: function (focusVisible) {\n            if (this._state.focusVisible !== focusVisible && !this._state.disabled) {\n                this._nextState({ focusVisible: focusVisible });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"maxDate\", {\n        set: function (date) {\n            var maxDate = this.toValidDate(date, null);\n            if (isChangedDate(this._state.maxDate, maxDate)) {\n                this._nextState({ maxDate: maxDate });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"markDisabled\", {\n        set: function (markDisabled) {\n            if (this._state.markDisabled !== markDisabled) {\n                this._nextState({ markDisabled: markDisabled });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"minDate\", {\n        set: function (date) {\n            var minDate = this.toValidDate(date, null);\n            if (isChangedDate(this._state.minDate, minDate)) {\n                this._nextState({ minDate: minDate });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(NgbDatepickerService.prototype, \"navigation\", {\n        set: function (navigation) {\n            if (this._state.navigation !== navigation) {\n                this._nextState({ navigation: navigation });\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    NgbDatepickerService.prototype.focus = function (date) {\n        if (!this._state.disabled && this._calendar.isValid(date) && isChangedDate(this._state.focusDate, date)) {\n            this._nextState({ focusDate: date });\n        }\n    };\n    NgbDatepickerService.prototype.focusMove = function (period, number) {\n        this.focus(this._calendar.getNext(this._state.focusDate, period, number));\n    };\n    NgbDatepickerService.prototype.focusSelect = function () {\n        if (isDateSelectable(this._state.focusDate, this._state)) {\n            this.select(this._state.focusDate, { emitEvent: true });\n        }\n    };\n    NgbDatepickerService.prototype.open = function (date) {\n        var firstDate = this.toValidDate(date, this._calendar.getToday());\n        if (!this._state.disabled) {\n            this._nextState({ firstDate: firstDate });\n        }\n    };\n    NgbDatepickerService.prototype.select = function (date, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var selectedDate = this.toValidDate(date, null);\n        if (!this._state.disabled) {\n            if (isChangedDate(this._state.selectedDate, selectedDate)) {\n                this._nextState({ selectedDate: selectedDate });\n            }\n            if (options.emitEvent && isDateSelectable(selectedDate, this._state)) {\n                this._select$.next(selectedDate);\n            }\n        }\n    };\n    NgbDatepickerService.prototype.toValidDate = function (date, defaultValue) {\n        var ngbDate = NgbDate.from(date);\n        if (defaultValue === undefined) {\n            defaultValue = this._calendar.getToday();\n        }\n        return this._calendar.isValid(ngbDate) ? ngbDate : defaultValue;\n    };\n    NgbDatepickerService.prototype._nextState = function (patch) {\n        var newState = this._updateState(patch);\n        this._patchContexts(newState);\n        this._state = newState;\n        this._model$.next(this._state);\n    };\n    NgbDatepickerService.prototype._patchContexts = function (state) {\n        state.months.forEach(function (month) {\n            month.weeks.forEach(function (week) {\n                week.days.forEach(function (day) {\n                    // patch focus flag\n                    if (state.focusDate) {\n                        day.context.focused = state.focusDate.equals(day.date) && state.focusVisible;\n                    }\n                    // override context disabled\n                    if (state.disabled === true) {\n                        day.context.disabled = true;\n                    }\n                    // patch selection flag\n                    if (state.selectedDate !== undefined) {\n                        day.context.selected = state.selectedDate !== null && state.selectedDate.equals(day.date);\n                    }\n                });\n            });\n        });\n    };\n    NgbDatepickerService.prototype._updateState = function (patch) {\n        // patching fields\n        var state = Object.assign({}, this._state, patch);\n        var startDate = state.firstDate;\n        // min/max dates changed\n        if ('minDate' in patch || 'maxDate' in patch) {\n            checkMinBeforeMax(state.minDate, state.maxDate);\n            state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n            state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n            startDate = state.focusDate;\n        }\n        // disabled\n        if ('disabled' in patch) {\n            state.focusVisible = false;\n        }\n        // initial rebuild via 'select()'\n        if ('selectedDate' in patch && this._state.months.length === 0) {\n            startDate = state.selectedDate;\n        }\n        // focus date changed\n        if ('focusDate' in patch) {\n            state.focusDate = checkDateInRange(state.focusDate, state.minDate, state.maxDate);\n            startDate = state.focusDate;\n            // nothing to rebuild if only focus changed and it is still visible\n            if (state.months.length !== 0 && !state.focusDate.before(state.firstDate) &&\n                !state.focusDate.after(state.lastDate)) {\n                return state;\n            }\n        }\n        // first date changed\n        if ('firstDate' in patch) {\n            state.firstDate = checkDateInRange(state.firstDate, state.minDate, state.maxDate);\n            startDate = state.firstDate;\n        }\n        // rebuilding months\n        if (startDate) {\n            var forceRebuild = 'firstDayOfWeek' in patch || 'markDisabled' in patch || 'minDate' in patch ||\n                'maxDate' in patch || 'disabled' in patch;\n            var months = buildMonths(this._calendar, startDate, state, forceRebuild);\n            // updating months and boundary dates\n            state.months = months;\n            state.firstDate = months.length > 0 ? months[0].firstDate : undefined;\n            state.lastDate = months.length > 0 ? months[months.length - 1].lastDate : undefined;\n            // reset selected date if 'markDisabled' returns true\n            if ('selectedDate' in patch && !isDateSelectable(state.selectedDate, state)) {\n                state.selectedDate = null;\n            }\n            // adjusting focus after months were built\n            if ('firstDate' in patch) {\n                if (state.focusDate === undefined || state.focusDate.before(state.firstDate) ||\n                    state.focusDate.after(state.lastDate)) {\n                    state.focusDate = startDate;\n                }\n            }\n            // adjusting months/years for the select box navigation\n            var yearChanged = !this._state.firstDate || this._state.firstDate.year !== state.firstDate.year;\n            var monthChanged = !this._state.firstDate || this._state.firstDate.month !== state.firstDate.month;\n            if (state.navigation === 'select') {\n                // years ->  boundaries (min/max were changed)\n                if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.years.length === 0 || yearChanged) {\n                    state.selectBoxes.years = generateSelectBoxYears(state.focusDate, state.minDate, state.maxDate);\n                }\n                // months -> when current year or boundaries change\n                if ('minDate' in patch || 'maxDate' in patch || state.selectBoxes.months.length === 0 || yearChanged) {\n                    state.selectBoxes.months =\n                        generateSelectBoxMonths(this._calendar, state.focusDate, state.minDate, state.maxDate);\n                }\n            }\n            else {\n                state.selectBoxes = { years: [], months: [] };\n            }\n            // updating navigation arrows -> boundaries change (min/max) or month/year changes\n            if ((state.navigation === 'arrows' || state.navigation === 'select') &&\n                (monthChanged || yearChanged || 'minDate' in patch || 'maxDate' in patch || 'disabled' in patch)) {\n                state.prevDisabled = state.disabled || prevMonthDisabled(this._calendar, state.firstDate, state.minDate);\n                state.nextDisabled = state.disabled || nextMonthDisabled(this._calendar, state.lastDate, state.maxDate);\n            }\n        }\n        return state;\n    };\n    return NgbDatepickerService;\n}());\nexport { NgbDatepickerService };\n//# sourceMappingURL=datepicker-service.js.map\n",null]}