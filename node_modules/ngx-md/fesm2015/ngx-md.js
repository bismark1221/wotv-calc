import { SecurityContext, Injectable, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ElementRef, Inject, PLATFORM_ID, Output, Input, NgModule } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { throwError } from 'rxjs';
import { map, catchError } from 'rxjs/operators';
import { Renderer, setOptions, parse } from 'marked';
import { DomSanitizer } from '@angular/platform-browser';
import { isPlatformBrowser, CommonModule } from '@angular/common';
import { highlightAll } from 'prismjs';

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-md.service.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMdService {
    /**
     * @param {?} _http
     * @param {?} _domSanitizer
     */
    constructor(_http, _domSanitizer) {
        this._http = _http;
        this._domSanitizer = _domSanitizer;
        this._renderer = new Renderer();
        this.extendRenderer();
        this.setMarkedOptions({});
    }
    // get the content from remote resource
    /**
     * @param {?} path
     * @return {?}
     */
    getContent(path) {
        return this._http.get(path, { responseType: 'text' }).pipe(map((/**
         * @param {?} res
         * @return {?}
         */
        res => this.extractData(res))), catchError(this.handleError));
    }
    /**
     * @return {?}
     */
    get renderer() {
        return this._renderer;
    }
    // handle data
    /**
     * @param {?} res
     * @return {?}
     */
    extractData(res) {
        return res || '';
    }
    /**
     * @param {?} options
     * @return {?}
     */
    setMarkedOptions(options) {
        options = Object.assign({
            gfm: true,
            tables: true,
            breaks: false,
            pedantic: false,
            sanitize: false,
            smartLists: true,
            smartypants: false,
        }, options);
        options.renderer = this._renderer;
        setOptions(options);
    }
    // comple markdown to html
    /**
     * @param {?} data
     * @param {?=} sanitize
     * @return {?}
     */
    compile(data, sanitize = true) {
        return this._domSanitizer.sanitize(sanitize ? SecurityContext.HTML : SecurityContext.NONE, parse(data).trim());
    }
    // handle error
    /**
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        /** @type {?} */
        const errMsg = error.message ? error.message : error.toString();
        return throwError(errMsg);
    }
    // extend marked render to support todo checkbox
    /**
     * @private
     * @return {?}
     */
    extendRenderer() {
        this._renderer.listitem = (/**
         * @param {?} text
         * @return {?}
         */
        function (text) {
            if (/^\s*\[[x ]\]\s*/.test(text)) {
                text = text
                    .replace(/^\s*\[ \]\s*/, '<input type="checkbox" class="md-checkbox" disabled> ')
                    .replace(/^\s*\[x\]\s*/, '<input type="checkbox" class="md-checkbox" checked disabled> ');
                return '<li style="list-style: none">' + text + '</li>';
            }
            else {
                return '<li>' + text + '</li>';
            }
        });
    }
}
NgxMdService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
/** @nocollapse */
NgxMdService.ctorParameters = () => [
    { type: HttpClient },
    { type: DomSanitizer }
];
/** @nocollapse */ NgxMdService.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgxMdService_Factory() { return new NgxMdService(ɵɵinject(HttpClient), ɵɵinject(DomSanitizer)); }, token: NgxMdService, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgxMdService.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    NgxMdService.prototype._http;
    /**
     * @type {?}
     * @private
     */
    NgxMdService.prototype._domSanitizer;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-md.component.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMdComponent {
    /**
     * @param {?} _mdService
     * @param {?} _el
     * @param {?} platformId
     */
    constructor(_mdService, _el, platformId) {
        this._mdService = _mdService;
        this._el = _el;
        this.platformId = platformId;
        this.changeLog = [];
        this.error = new EventEmitter();
        this.loaded = new EventEmitter();
        /**
         * Boolean indicating if the markdown content should be sanitized to avoid script injections
         */
        this.sanitizeHtml = true;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set path(value) {
        if (value) {
            this._path = value;
            this.onPathChange();
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set data(value) {
        if (value) {
            this._data = value;
            this.onDataChange(value);
        }
    }
    // on input
    /**
     * @param {?} data
     * @return {?}
     */
    onDataChange(data) {
        if (data) {
            this._el.nativeElement.innerHTML = this._mdService.compile(data, this.sanitizeHtml);
        }
        else {
            this._el.nativeElement.innerHTML = '';
        }
        this.highlightContent(false);
    }
    /**
     *  After view init
     * @return {?}
     */
    ngAfterViewInit() {
        if (this._path) {
            this.onPathChange();
        }
        else if (!this._data) {
            this.processRaw();
        }
    }
    /**
     * @return {?}
     */
    processRaw() {
        this._md = this.prepare(decodeHtml(this._el.nativeElement.innerHTML));
        this._el.nativeElement.innerHTML = this._mdService.compile(this._md, this.sanitizeHtml);
        this.highlightContent(false);
    }
    /**
     * get remote conent;
     * @return {?}
     */
    onPathChange() {
        this._ext =
            this._path &&
                this._path
                    .split('.')
                    .splice(-1)
                    .join();
        this._mdService
            .getContent(this._path)
            .pipe(catchError(this.handleError))
            .subscribe((/**
         * @param {?} data
         * @return {?}
         */
        data => {
            this.loaded.emit(data);
            this._md =
                this._ext !== 'md' ? '```' + this._ext + '\n' + data + '\n```' : data;
            this._el.nativeElement.innerHTML = this._mdService.compile(this.prepare(this._md), this.sanitizeHtml);
            this.highlightContent(false);
        }));
    }
    /**
     * catch http error
     * @private
     * @param {?} error
     * @return {?}
     */
    handleError(error) {
        this.error.emit(error);
        console.error('An error occurred', error); // for demo purposes only
        return error.message || error;
    }
    /**
     * Prepare string
     * @param {?} raw
     * @return {?}
     */
    prepare(raw) {
        if (!raw) {
            return '';
        }
        if (this._ext === 'md' || !this.path) {
            /** @type {?} */
            let isCodeBlock = false;
            return raw
                .split('\n')
                .map((/**
             * @param {?} line
             * @return {?}
             */
            (line) => {
                // If the first non-blank chars are an opening/closing code block, toggle the flag
                if (this.trimLeft(line).substring(0, 3) === '```') {
                    isCodeBlock = !isCodeBlock;
                }
                return isCodeBlock ? line : line.trim();
            }))
                .join('\n');
        }
        return raw.replace(/\"/g, '\'');
    }
    /**
     * Trim left whitespace
     * @private
     * @param {?} line
     * @return {?}
     */
    trimLeft(line) {
        return line.replace(/^\s+|\s+$/g, '');
    }
    /**
     * Use Prism to highlight code snippets only on the browser
     * @private
     * @param {?} async
     * @return {?}
     */
    highlightContent(async) {
        if (isPlatformBrowser(this.platformId)) {
            highlightAll(async);
        }
    }
}
NgxMdComponent.decorators = [
    { type: Component, args: [{
                selector: 'markdown,[Markdown],ngx-md,[NgxMd]',
                template: '<ng-content></ng-content>',
                styles: [`
      .token.operator,
      .token.entity,
      .token.url,
      .language-css .token.string,
      .style .token.string {
        background: none;
      }
      .md-checkbox {
        vertical-align: middle;
        margin: 0 0.2em 0.25em -1.6em;
        font-size: 16px;
      }
    `]
            }] }
];
/** @nocollapse */
NgxMdComponent.ctorParameters = () => [
    { type: NgxMdService },
    { type: ElementRef },
    { type: String, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
NgxMdComponent.propDecorators = {
    error: [{ type: Output }],
    loaded: [{ type: Output }],
    path: [{ type: Input }],
    data: [{ type: Input }],
    sanitizeHtml: [{ type: Input }]
};
if (false) {
    /** @type {?} */
    NgxMdComponent.prototype._path;
    /** @type {?} */
    NgxMdComponent.prototype._data;
    /** @type {?} */
    NgxMdComponent.prototype._md;
    /** @type {?} */
    NgxMdComponent.prototype._ext;
    /** @type {?} */
    NgxMdComponent.prototype.changeLog;
    /** @type {?} */
    NgxMdComponent.prototype.error;
    /** @type {?} */
    NgxMdComponent.prototype.loaded;
    /**
     * Boolean indicating if the markdown content should be sanitized to avoid script injections
     * @type {?}
     */
    NgxMdComponent.prototype.sanitizeHtml;
    /** @type {?} */
    NgxMdComponent.prototype._mdService;
    /** @type {?} */
    NgxMdComponent.prototype._el;
    /** @type {?} */
    NgxMdComponent.prototype.platformId;
}
/**
 * @param {?} html
 * @return {?}
 */
function decodeHtml(html) {
    // https://stackoverflow.com/a/7394787/588521
    /** @type {?} */
    const txt = document.createElement('textarea');
    txt.innerHTML = html;
    return txt.value;
}

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-md.config.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMdConfig {
}
NgxMdConfig.decorators = [
    { type: Injectable }
];

/**
 * @fileoverview added by tsickle
 * Generated from: lib/ngx-md.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgxMdModule {
    /**
     * @return {?}
     */
    static forRoot() {
        return {
            ngModule: NgxMdModule,
            providers: [NgxMdConfig],
        };
    }
}
NgxMdModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                declarations: [NgxMdComponent],
                providers: [NgxMdService],
                exports: [NgxMdComponent],
            },] }
];

/**
 * @fileoverview added by tsickle
 * Generated from: index.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * Generated from: ngx-md.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NgxMdComponent, NgxMdModule, NgxMdService, NgxMdConfig as ɵa };
//# sourceMappingURL=ngx-md.js.map
