import { TestBed, fakeAsync, inject, tick } from '@angular/core/testing';
import { LightboxEvent, LIGHTBOX_EVENT } from './lightbox-event.service';
import { LightboxOverlayComponent } from './lightbox-overlay.component';
describe('[ Unit - LightboxOverlayComponent ]', function () {
    var fixture;
    var lightboxEvent;
    var mockData;
    beforeEach(function () {
        mockData = {
            options: {
                fadeDuration: 1
            }
        };
    });
    beforeEach(function () {
        TestBed.configureTestingModule({
            declarations: [LightboxOverlayComponent],
            providers: [LightboxEvent]
        });
        fixture = TestBed.createComponent(LightboxOverlayComponent);
        // mock options and ref
        fixture.componentInstance.options = mockData.options;
        fixture.componentInstance.cmpRef = { destroy: jasmine.createSpy('spy') };
        fixture.detectChanges();
    });
    beforeEach(inject([LightboxEvent], function (lEvent) {
        lightboxEvent = lEvent;
    }));
    it('should init the component with correct styling', function () {
        expect(fixture.nativeElement.getAttribute('class')).toContain('lightboxOverlay animation fadeInOverlay');
        expect(fixture.nativeElement.getAttribute('style'))
            .toMatch(new RegExp("animation.*" + mockData.options.fadeDuration + "s"));
    });
    describe('{ method: close }', function () {
        it('should self destroy and broadcast event when component is closed', fakeAsync(function () {
            spyOn(lightboxEvent, 'broadcastLightboxEvent').and.callThrough();
            fixture.componentInstance.close();
            expect(lightboxEvent.broadcastLightboxEvent).toHaveBeenCalledWith({ id: LIGHTBOX_EVENT.CLOSE, data: null });
            tick();
            fixture.detectChanges();
            expect(fixture.nativeElement.getAttribute('class')).toContain('lightboxOverlay animation fadeOutOverlay');
            tick(mockData.options.fadeDuration * 1000 + 1);
            expect(fixture.componentInstance.cmpRef.destroy).toHaveBeenCalledTimes(1);
        }));
    });
    describe('{ method: ngOnDestroy }', function () {
        it('should unsubscribe event when destroy is called', function () {
            spyOn(fixture.componentInstance['_subscription'], 'unsubscribe').and.callFake(function () { });
            fixture.componentInstance.ngOnDestroy();
            expect(fixture.componentInstance['_subscription'].unsubscribe).toHaveBeenCalledTimes(1);
        });
    });
});
//# sourceMappingURL=lightbox-overlay.component.spec.js.map