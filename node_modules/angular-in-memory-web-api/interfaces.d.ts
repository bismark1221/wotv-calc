import { Observable } from 'rxjs';
/**
 *  Minimum definition needed by base class
 */
import * as ɵngcc0 from '@angular/core';
export interface HeadersCore {
    set(name: string, value: string): void | any;
}
/**
* Interface for a class that creates an in-memory database
*
* Its `createDb` method creates a hash of named collections that represents the database
*
* For maximum flexibility, the service may define HTTP method overrides.
* Such methods must match the spelling of an HTTP method in lower case (e.g, "get").
* If a request has a matching method, it will be called as in
* `get(info: requestInfo, db: {})` where `db` is the database object described above.
*/
export declare abstract class InMemoryDbService {
    /**
    * Creates an in-memory "database" hash whose keys are collection names
    * and whose values are arrays of collection objects to return or update.
    *
    * returns Observable of the database because could have to create it asynchronously.
    *
    * This method must be safe to call repeatedly.
    * Each time it should return a new object with new arrays containing new item objects.
    * This condition allows the in-memory backend service to mutate the collections
    * and their items without touching the original source data.
    *
    * The in-mem backend service calls this method without a value the first time.
    * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.
    * Your InMemoryDbService can adjust its behavior accordingly.
    */
    abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;
}
/**
* Interface for InMemoryBackend configuration options
*/
export declare abstract class InMemoryBackendConfigArgs {
    /**
     * The base path to the api, e.g, 'api/'.
     * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.
     */
    apiBase?: string;
    /**
     * false (default) if search match should be case insensitive
     */
    caseSensitiveSearch?: boolean;
    /**
     * false (default) put content directly inside the response body.
     * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.
     */
    dataEncapsulation?: boolean;
    /**
     * delay (in ms) to simulate latency
     */
    delay?: number;
    /**
     * false (default) should 204 when object-to-delete not found; true: 404
     */
    delete404?: boolean;
    /**
     * host for this service, e.g., 'localhost'
     */
    host?: string;
    /**
     * false (default) should pass unrecognized request URL through to original backend; true: 404
     */
    passThruUnknownUrl?: boolean;
    /**
     * true (default) should NOT return the item (204) after a POST. false: return the item (200).
     */
    post204?: boolean;
    /**
    * false (default) should NOT update existing item with POST. false: OK to update.
    */
    post409?: boolean;
    /**
    * true (default) should NOT return the item (204) after a POST. false: return the item (200).
    */
    put204?: boolean;
    /**
     * false (default) if item not found, create as new item; false: should 404.
     */
    put404?: boolean;
    /**
     * root path _before_ any API call, e.g., ''
     */
    rootPath?: string;
}
/**
*  InMemoryBackendService configuration options
*  Usage:
*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})
*
*  or if providing separately:
*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),
*/
export declare class InMemoryBackendConfig implements InMemoryBackendConfigArgs {
    constructor(config?: InMemoryBackendConfigArgs);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<InMemoryBackendConfig, never>;
    static ɵprov: ɵngcc0.ɵɵInjectableDef<InMemoryBackendConfig>;
}
/** Return information (UriInfo) about a URI  */
export declare function parseUri(str: string): UriInfo;
/**
 *
 * Interface for the result of the `parseRequestUrl` method:
 *   Given URL "http://localhost:8080/api/customers/42?foo=1 the default implementation returns
 *     base: 'api/'
 *     collectionName: 'customers'
 *     id: '42'
 *     query: this.createQuery('foo=1')
 *     resourceUrl: 'http://localhost/api/customers/'
 */
export interface ParsedRequestUrl {
    apiBase: string;
    collectionName: string;
    id: string;
    query: Map<string, string[]>;
    resourceUrl: string;
}
export interface PassThruBackend {
    /**
     * Handle an HTTP request and return an Observable of HTTP response
     * Both the request type and the response type are determined by the supporting HTTP library.
     */
    handle(req: any): Observable<any>;
}
export declare function removeTrailingSlash(path: string): string;
/**
 *  Minimum definition needed by base class
 */
export interface RequestCore {
    url: string;
    urlWithParams?: string;
}
/**
* Interface for object w/ info about the current request url
* extracted from an Http Request.
* Also holds utility methods and configuration data from this service
*/
export interface RequestInfo {
    req: RequestCore;
    apiBase: string;
    collectionName: string;
    collection: any;
    headers: HeadersCore;
    method: string;
    id: any;
    query: Map<string, string[]>;
    resourceUrl: string;
    url: string;
    utils: RequestInfoUtilities;
}
/**
 * Interface for utility methods from this service instance.
 * Useful within an HTTP method override
 */
export interface RequestInfoUtilities {
    /**
     * Create a cold response Observable from a factory for ResponseOptions
     * the same way that the in-mem backend service does.
     * @param resOptionsFactory - creates ResponseOptions when observable is subscribed
     * @param withDelay - if true (default), add simulated latency delay from configuration
     */
    createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;
    /**
     * Find first instance of item in collection by `item.id`
     * @param collection
     * @param id
     */
    findById<T extends {
        id: any;
    }>(collection: T[], id: any): T;
    /** return the current, active configuration which is a blend of defaults and overrides */
    getConfig(): InMemoryBackendConfigArgs;
    /** Get the in-mem service's copy of the "database" */
    getDb(): {};
    /** Get JSON body from the request object */
    getJsonBody(req: any): any;
    /** Get location info from a url, even on server where `document` is not defined */
    getLocation(url: string): UriInfo;
    /** Get (or create) the "real" backend */
    getPassThruBackend(): PassThruBackend;
    /**
     * return true if can determine that the collection's `item.id` is a number
     * */
    isCollectionIdNumeric<T extends {
        id: any;
    }>(collection: T[], collectionName: string): boolean;
    /**
     * Parses the request URL into a `ParsedRequestUrl` object.
     * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.
     */
    parseRequestUrl(url: string): ParsedRequestUrl;
}
/**
 * Provide a `responseInterceptor` method of this type in your `inMemDbService` to
 * morph the response options created in the `collectionHandler`.
 */
export declare type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;
export interface ResponseOptions {
    /**
     * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.
     */
    body?: string | Object | ArrayBuffer | Blob;
    /**
     * Response headers
     */
    headers?: HeadersCore;
    /**
     * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}
     * associated with the response.
     */
    status?: number;
    /**
     * Status text for the status code
     */
    statusText?: string;
    /**
     * request url
     */
    url?: string;
}
/** Interface of information about a Uri  */
export interface UriInfo {
    source: string;
    protocol: string;
    authority: string;
    userInfo: string;
    user: string;
    password: string;
    host: string;
    port: string;
    relative: string;
    path: string;
    directory: string;
    file: string;
    query: string;
    anchor: string;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJmYWNlcy5kLnRzIiwic291cmNlcyI6WyJpbnRlcmZhY2VzLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuLyoqXG4gKiAgTWluaW11bSBkZWZpbml0aW9uIG5lZWRlZCBieSBiYXNlIGNsYXNzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSGVhZGVyc0NvcmUge1xuICAgIHNldChuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHwgYW55O1xufVxuLyoqXG4qIEludGVyZmFjZSBmb3IgYSBjbGFzcyB0aGF0IGNyZWF0ZXMgYW4gaW4tbWVtb3J5IGRhdGFiYXNlXG4qXG4qIEl0cyBgY3JlYXRlRGJgIG1ldGhvZCBjcmVhdGVzIGEgaGFzaCBvZiBuYW1lZCBjb2xsZWN0aW9ucyB0aGF0IHJlcHJlc2VudHMgdGhlIGRhdGFiYXNlXG4qXG4qIEZvciBtYXhpbXVtIGZsZXhpYmlsaXR5LCB0aGUgc2VydmljZSBtYXkgZGVmaW5lIEhUVFAgbWV0aG9kIG92ZXJyaWRlcy5cbiogU3VjaCBtZXRob2RzIG11c3QgbWF0Y2ggdGhlIHNwZWxsaW5nIG9mIGFuIEhUVFAgbWV0aG9kIGluIGxvd2VyIGNhc2UgKGUuZywgXCJnZXRcIikuXG4qIElmIGEgcmVxdWVzdCBoYXMgYSBtYXRjaGluZyBtZXRob2QsIGl0IHdpbGwgYmUgY2FsbGVkIGFzIGluXG4qIGBnZXQoaW5mbzogcmVxdWVzdEluZm8sIGRiOiB7fSlgIHdoZXJlIGBkYmAgaXMgdGhlIGRhdGFiYXNlIG9iamVjdCBkZXNjcmliZWQgYWJvdmUuXG4qL1xuZXhwb3J0IGRlY2xhcmUgYWJzdHJhY3QgY2xhc3MgSW5NZW1vcnlEYlNlcnZpY2Uge1xuICAgIC8qKlxuICAgICogQ3JlYXRlcyBhbiBpbi1tZW1vcnkgXCJkYXRhYmFzZVwiIGhhc2ggd2hvc2Uga2V5cyBhcmUgY29sbGVjdGlvbiBuYW1lc1xuICAgICogYW5kIHdob3NlIHZhbHVlcyBhcmUgYXJyYXlzIG9mIGNvbGxlY3Rpb24gb2JqZWN0cyB0byByZXR1cm4gb3IgdXBkYXRlLlxuICAgICpcbiAgICAqIHJldHVybnMgT2JzZXJ2YWJsZSBvZiB0aGUgZGF0YWJhc2UgYmVjYXVzZSBjb3VsZCBoYXZlIHRvIGNyZWF0ZSBpdCBhc3luY2hyb25vdXNseS5cbiAgICAqXG4gICAgKiBUaGlzIG1ldGhvZCBtdXN0IGJlIHNhZmUgdG8gY2FsbCByZXBlYXRlZGx5LlxuICAgICogRWFjaCB0aW1lIGl0IHNob3VsZCByZXR1cm4gYSBuZXcgb2JqZWN0IHdpdGggbmV3IGFycmF5cyBjb250YWluaW5nIG5ldyBpdGVtIG9iamVjdHMuXG4gICAgKiBUaGlzIGNvbmRpdGlvbiBhbGxvd3MgdGhlIGluLW1lbW9yeSBiYWNrZW5kIHNlcnZpY2UgdG8gbXV0YXRlIHRoZSBjb2xsZWN0aW9uc1xuICAgICogYW5kIHRoZWlyIGl0ZW1zIHdpdGhvdXQgdG91Y2hpbmcgdGhlIG9yaWdpbmFsIHNvdXJjZSBkYXRhLlxuICAgICpcbiAgICAqIFRoZSBpbi1tZW0gYmFja2VuZCBzZXJ2aWNlIGNhbGxzIHRoaXMgbWV0aG9kIHdpdGhvdXQgYSB2YWx1ZSB0aGUgZmlyc3QgdGltZS5cbiAgICAqIFRoZSBzZXJ2aWNlIGNhbGxzIGl0IHdpdGggdGhlIGBSZXF1ZXN0SW5mb2Agd2hlbiBpdCByZWNlaXZlcyBhIFBPU1QgYGNvbW1hbmRzL3Jlc2V0RGJgIHJlcXVlc3QuXG4gICAgKiBZb3VyIEluTWVtb3J5RGJTZXJ2aWNlIGNhbiBhZGp1c3QgaXRzIGJlaGF2aW9yIGFjY29yZGluZ2x5LlxuICAgICovXG4gICAgYWJzdHJhY3QgY3JlYXRlRGIocmVxSW5mbz86IFJlcXVlc3RJbmZvKToge30gfCBPYnNlcnZhYmxlPHt9PiB8IFByb21pc2U8e30+O1xufVxuLyoqXG4qIEludGVyZmFjZSBmb3IgSW5NZW1vcnlCYWNrZW5kIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xuKi9cbmV4cG9ydCBkZWNsYXJlIGFic3RyYWN0IGNsYXNzIEluTWVtb3J5QmFja2VuZENvbmZpZ0FyZ3Mge1xuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIHBhdGggdG8gdGhlIGFwaSwgZS5nLCAnYXBpLycuXG4gICAgICogSWYgbm90IHNwZWNpZmllZCB0aGFuIGBwYXJzZVJlcXVlc3RVcmxgIGFzc3VtZXMgaXQgaXMgdGhlIGZpcnN0IHBhdGggc2VnbWVudCBpbiB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBhcGlCYXNlPzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIGZhbHNlIChkZWZhdWx0KSBpZiBzZWFyY2ggbWF0Y2ggc2hvdWxkIGJlIGNhc2UgaW5zZW5zaXRpdmVcbiAgICAgKi9cbiAgICBjYXNlU2Vuc2l0aXZlU2VhcmNoPzogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBmYWxzZSAoZGVmYXVsdCkgcHV0IGNvbnRlbnQgZGlyZWN0bHkgaW5zaWRlIHRoZSByZXNwb25zZSBib2R5LlxuICAgICAqIHRydWU6IGVuY2Fwc3VsYXRlIGNvbnRlbnQgaW4gYSBgZGF0YWAgcHJvcGVydHkgaW5zaWRlIHRoZSByZXNwb25zZSBib2R5LCBgeyBkYXRhOiAuLi4gfWAuXG4gICAgICovXG4gICAgZGF0YUVuY2Fwc3VsYXRpb24/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIGRlbGF5IChpbiBtcykgdG8gc2ltdWxhdGUgbGF0ZW5jeVxuICAgICAqL1xuICAgIGRlbGF5PzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIGZhbHNlIChkZWZhdWx0KSBzaG91bGQgMjA0IHdoZW4gb2JqZWN0LXRvLWRlbGV0ZSBub3QgZm91bmQ7IHRydWU6IDQwNFxuICAgICAqL1xuICAgIGRlbGV0ZTQwND86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogaG9zdCBmb3IgdGhpcyBzZXJ2aWNlLCBlLmcuLCAnbG9jYWxob3N0J1xuICAgICAqL1xuICAgIGhvc3Q/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogZmFsc2UgKGRlZmF1bHQpIHNob3VsZCBwYXNzIHVucmVjb2duaXplZCByZXF1ZXN0IFVSTCB0aHJvdWdoIHRvIG9yaWdpbmFsIGJhY2tlbmQ7IHRydWU6IDQwNFxuICAgICAqL1xuICAgIHBhc3NUaHJ1VW5rbm93blVybD86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogdHJ1ZSAoZGVmYXVsdCkgc2hvdWxkIE5PVCByZXR1cm4gdGhlIGl0ZW0gKDIwNCkgYWZ0ZXIgYSBQT1NULiBmYWxzZTogcmV0dXJuIHRoZSBpdGVtICgyMDApLlxuICAgICAqL1xuICAgIHBvc3QyMDQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICogZmFsc2UgKGRlZmF1bHQpIHNob3VsZCBOT1QgdXBkYXRlIGV4aXN0aW5nIGl0ZW0gd2l0aCBQT1NULiBmYWxzZTogT0sgdG8gdXBkYXRlLlxuICAgICovXG4gICAgcG9zdDQwOT86IGJvb2xlYW47XG4gICAgLyoqXG4gICAgKiB0cnVlIChkZWZhdWx0KSBzaG91bGQgTk9UIHJldHVybiB0aGUgaXRlbSAoMjA0KSBhZnRlciBhIFBPU1QuIGZhbHNlOiByZXR1cm4gdGhlIGl0ZW0gKDIwMCkuXG4gICAgKi9cbiAgICBwdXQyMDQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIGZhbHNlIChkZWZhdWx0KSBpZiBpdGVtIG5vdCBmb3VuZCwgY3JlYXRlIGFzIG5ldyBpdGVtOyBmYWxzZTogc2hvdWxkIDQwNC5cbiAgICAgKi9cbiAgICBwdXQ0MDQ/OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIHJvb3QgcGF0aCBfYmVmb3JlXyBhbnkgQVBJIGNhbGwsIGUuZy4sICcnXG4gICAgICovXG4gICAgcm9vdFBhdGg/OiBzdHJpbmc7XG59XG4vKipcbiogIEluTWVtb3J5QmFja2VuZFNlcnZpY2UgY29uZmlndXJhdGlvbiBvcHRpb25zXG4qICBVc2FnZTpcbiogICAgSW5NZW1vcnlXZWJBcGlNb2R1bGUuZm9yUm9vdChJbk1lbUhlcm9TZXJ2aWNlLCB7ZGVsYXk6IDYwMH0pXG4qXG4qICBvciBpZiBwcm92aWRpbmcgc2VwYXJhdGVseTpcbiogICAgcHJvdmlkZShJbk1lbW9yeUJhY2tlbmRDb25maWcsIHt1c2VWYWx1ZToge2RlbGF5OiA2MDB9fSksXG4qL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgSW5NZW1vcnlCYWNrZW5kQ29uZmlnIGltcGxlbWVudHMgSW5NZW1vcnlCYWNrZW5kQ29uZmlnQXJncyB7XG4gICAgY29uc3RydWN0b3IoY29uZmlnPzogSW5NZW1vcnlCYWNrZW5kQ29uZmlnQXJncyk7XG59XG4vKiogUmV0dXJuIGluZm9ybWF0aW9uIChVcmlJbmZvKSBhYm91dCBhIFVSSSAgKi9cbmV4cG9ydCBkZWNsYXJlIGZ1bmN0aW9uIHBhcnNlVXJpKHN0cjogc3RyaW5nKTogVXJpSW5mbztcbi8qKlxuICpcbiAqIEludGVyZmFjZSBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgYHBhcnNlUmVxdWVzdFVybGAgbWV0aG9kOlxuICogICBHaXZlbiBVUkwgXCJodHRwOi8vbG9jYWxob3N0OjgwODAvYXBpL2N1c3RvbWVycy80Mj9mb289MSB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zXG4gKiAgICAgYmFzZTogJ2FwaS8nXG4gKiAgICAgY29sbGVjdGlvbk5hbWU6ICdjdXN0b21lcnMnXG4gKiAgICAgaWQ6ICc0MidcbiAqICAgICBxdWVyeTogdGhpcy5jcmVhdGVRdWVyeSgnZm9vPTEnKVxuICogICAgIHJlc291cmNlVXJsOiAnaHR0cDovL2xvY2FsaG9zdC9hcGkvY3VzdG9tZXJzLydcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYXJzZWRSZXF1ZXN0VXJsIHtcbiAgICBhcGlCYXNlOiBzdHJpbmc7XG4gICAgY29sbGVjdGlvbk5hbWU6IHN0cmluZztcbiAgICBpZDogc3RyaW5nO1xuICAgIHF1ZXJ5OiBNYXA8c3RyaW5nLCBzdHJpbmdbXT47XG4gICAgcmVzb3VyY2VVcmw6IHN0cmluZztcbn1cbmV4cG9ydCBpbnRlcmZhY2UgUGFzc1RocnVCYWNrZW5kIHtcbiAgICAvKipcbiAgICAgKiBIYW5kbGUgYW4gSFRUUCByZXF1ZXN0IGFuZCByZXR1cm4gYW4gT2JzZXJ2YWJsZSBvZiBIVFRQIHJlc3BvbnNlXG4gICAgICogQm90aCB0aGUgcmVxdWVzdCB0eXBlIGFuZCB0aGUgcmVzcG9uc2UgdHlwZSBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgc3VwcG9ydGluZyBIVFRQIGxpYnJhcnkuXG4gICAgICovXG4gICAgaGFuZGxlKHJlcTogYW55KTogT2JzZXJ2YWJsZTxhbnk+O1xufVxuZXhwb3J0IGRlY2xhcmUgZnVuY3Rpb24gcmVtb3ZlVHJhaWxpbmdTbGFzaChwYXRoOiBzdHJpbmcpOiBzdHJpbmc7XG4vKipcbiAqICBNaW5pbXVtIGRlZmluaXRpb24gbmVlZGVkIGJ5IGJhc2UgY2xhc3NcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXF1ZXN0Q29yZSB7XG4gICAgdXJsOiBzdHJpbmc7XG4gICAgdXJsV2l0aFBhcmFtcz86IHN0cmluZztcbn1cbi8qKlxuKiBJbnRlcmZhY2UgZm9yIG9iamVjdCB3LyBpbmZvIGFib3V0IHRoZSBjdXJyZW50IHJlcXVlc3QgdXJsXG4qIGV4dHJhY3RlZCBmcm9tIGFuIEh0dHAgUmVxdWVzdC5cbiogQWxzbyBob2xkcyB1dGlsaXR5IG1ldGhvZHMgYW5kIGNvbmZpZ3VyYXRpb24gZGF0YSBmcm9tIHRoaXMgc2VydmljZVxuKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdEluZm8ge1xuICAgIHJlcTogUmVxdWVzdENvcmU7XG4gICAgYXBpQmFzZTogc3RyaW5nO1xuICAgIGNvbGxlY3Rpb25OYW1lOiBzdHJpbmc7XG4gICAgY29sbGVjdGlvbjogYW55O1xuICAgIGhlYWRlcnM6IEhlYWRlcnNDb3JlO1xuICAgIG1ldGhvZDogc3RyaW5nO1xuICAgIGlkOiBhbnk7XG4gICAgcXVlcnk6IE1hcDxzdHJpbmcsIHN0cmluZ1tdPjtcbiAgICByZXNvdXJjZVVybDogc3RyaW5nO1xuICAgIHVybDogc3RyaW5nO1xuICAgIHV0aWxzOiBSZXF1ZXN0SW5mb1V0aWxpdGllcztcbn1cbi8qKlxuICogSW50ZXJmYWNlIGZvciB1dGlsaXR5IG1ldGhvZHMgZnJvbSB0aGlzIHNlcnZpY2UgaW5zdGFuY2UuXG4gKiBVc2VmdWwgd2l0aGluIGFuIEhUVFAgbWV0aG9kIG92ZXJyaWRlXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUmVxdWVzdEluZm9VdGlsaXRpZXMge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbGQgcmVzcG9uc2UgT2JzZXJ2YWJsZSBmcm9tIGEgZmFjdG9yeSBmb3IgUmVzcG9uc2VPcHRpb25zXG4gICAgICogdGhlIHNhbWUgd2F5IHRoYXQgdGhlIGluLW1lbSBiYWNrZW5kIHNlcnZpY2UgZG9lcy5cbiAgICAgKiBAcGFyYW0gcmVzT3B0aW9uc0ZhY3RvcnkgLSBjcmVhdGVzIFJlc3BvbnNlT3B0aW9ucyB3aGVuIG9ic2VydmFibGUgaXMgc3Vic2NyaWJlZFxuICAgICAqIEBwYXJhbSB3aXRoRGVsYXkgLSBpZiB0cnVlIChkZWZhdWx0KSwgYWRkIHNpbXVsYXRlZCBsYXRlbmN5IGRlbGF5IGZyb20gY29uZmlndXJhdGlvblxuICAgICAqL1xuICAgIGNyZWF0ZVJlc3BvbnNlJDogKHJlc09wdGlvbnNGYWN0b3J5OiAoKSA9PiBSZXNwb25zZU9wdGlvbnMpID0+IE9ic2VydmFibGU8YW55PjtcbiAgICAvKipcbiAgICAgKiBGaW5kIGZpcnN0IGluc3RhbmNlIG9mIGl0ZW0gaW4gY29sbGVjdGlvbiBieSBgaXRlbS5pZGBcbiAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxuICAgICAqIEBwYXJhbSBpZFxuICAgICAqL1xuICAgIGZpbmRCeUlkPFQgZXh0ZW5kcyB7XG4gICAgICAgIGlkOiBhbnk7XG4gICAgfT4oY29sbGVjdGlvbjogVFtdLCBpZDogYW55KTogVDtcbiAgICAvKiogcmV0dXJuIHRoZSBjdXJyZW50LCBhY3RpdmUgY29uZmlndXJhdGlvbiB3aGljaCBpcyBhIGJsZW5kIG9mIGRlZmF1bHRzIGFuZCBvdmVycmlkZXMgKi9cbiAgICBnZXRDb25maWcoKTogSW5NZW1vcnlCYWNrZW5kQ29uZmlnQXJncztcbiAgICAvKiogR2V0IHRoZSBpbi1tZW0gc2VydmljZSdzIGNvcHkgb2YgdGhlIFwiZGF0YWJhc2VcIiAqL1xuICAgIGdldERiKCk6IHt9O1xuICAgIC8qKiBHZXQgSlNPTiBib2R5IGZyb20gdGhlIHJlcXVlc3Qgb2JqZWN0ICovXG4gICAgZ2V0SnNvbkJvZHkocmVxOiBhbnkpOiBhbnk7XG4gICAgLyoqIEdldCBsb2NhdGlvbiBpbmZvIGZyb20gYSB1cmwsIGV2ZW4gb24gc2VydmVyIHdoZXJlIGBkb2N1bWVudGAgaXMgbm90IGRlZmluZWQgKi9cbiAgICBnZXRMb2NhdGlvbih1cmw6IHN0cmluZyk6IFVyaUluZm87XG4gICAgLyoqIEdldCAob3IgY3JlYXRlKSB0aGUgXCJyZWFsXCIgYmFja2VuZCAqL1xuICAgIGdldFBhc3NUaHJ1QmFja2VuZCgpOiBQYXNzVGhydUJhY2tlbmQ7XG4gICAgLyoqXG4gICAgICogcmV0dXJuIHRydWUgaWYgY2FuIGRldGVybWluZSB0aGF0IHRoZSBjb2xsZWN0aW9uJ3MgYGl0ZW0uaWRgIGlzIGEgbnVtYmVyXG4gICAgICogKi9cbiAgICBpc0NvbGxlY3Rpb25JZE51bWVyaWM8VCBleHRlbmRzIHtcbiAgICAgICAgaWQ6IGFueTtcbiAgICB9Pihjb2xsZWN0aW9uOiBUW10sIGNvbGxlY3Rpb25OYW1lOiBzdHJpbmcpOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFBhcnNlcyB0aGUgcmVxdWVzdCBVUkwgaW50byBhIGBQYXJzZWRSZXF1ZXN0VXJsYCBvYmplY3QuXG4gICAgICogUGFyc2luZyBkZXBlbmRzIHVwb24gY2VydGFpbiB2YWx1ZXMgb2YgYGNvbmZpZ2A6IGBhcGlCYXNlYCwgYGhvc3RgLCBhbmQgYHVybFJvb3RgLlxuICAgICAqL1xuICAgIHBhcnNlUmVxdWVzdFVybCh1cmw6IHN0cmluZyk6IFBhcnNlZFJlcXVlc3RVcmw7XG59XG4vKipcbiAqIFByb3ZpZGUgYSBgcmVzcG9uc2VJbnRlcmNlcHRvcmAgbWV0aG9kIG9mIHRoaXMgdHlwZSBpbiB5b3VyIGBpbk1lbURiU2VydmljZWAgdG9cbiAqIG1vcnBoIHRoZSByZXNwb25zZSBvcHRpb25zIGNyZWF0ZWQgaW4gdGhlIGBjb2xsZWN0aW9uSGFuZGxlcmAuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIHR5cGUgUmVzcG9uc2VJbnRlcmNlcHRvciA9IChyZXM6IFJlc3BvbnNlT3B0aW9ucywgcmk6IFJlcXVlc3RJbmZvKSA9PiBSZXNwb25zZU9wdGlvbnM7XG5leHBvcnQgaW50ZXJmYWNlIFJlc3BvbnNlT3B0aW9ucyB7XG4gICAgLyoqXG4gICAgICogU3RyaW5nLCBPYmplY3QsIEFycmF5QnVmZmVyIG9yIEJsb2IgcmVwcmVzZW50aW5nIHRoZSBib2R5IG9mIHRoZSB7QGxpbmsgUmVzcG9uc2V9LlxuICAgICAqL1xuICAgIGJvZHk/OiBzdHJpbmcgfCBPYmplY3QgfCBBcnJheUJ1ZmZlciB8IEJsb2I7XG4gICAgLyoqXG4gICAgICogUmVzcG9uc2UgaGVhZGVyc1xuICAgICAqL1xuICAgIGhlYWRlcnM/OiBIZWFkZXJzQ29yZTtcbiAgICAvKipcbiAgICAgKiBIdHRwIHtAbGluayBodHRwOi8vd3d3LnczLm9yZy9Qcm90b2NvbHMvcmZjMjYxNi9yZmMyNjE2LXNlYzEwLmh0bWwgc3RhdHVzIGNvZGV9XG4gICAgICogYXNzb2NpYXRlZCB3aXRoIHRoZSByZXNwb25zZS5cbiAgICAgKi9cbiAgICBzdGF0dXM/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU3RhdHVzIHRleHQgZm9yIHRoZSBzdGF0dXMgY29kZVxuICAgICAqL1xuICAgIHN0YXR1c1RleHQ/OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogcmVxdWVzdCB1cmxcbiAgICAgKi9cbiAgICB1cmw/OiBzdHJpbmc7XG59XG4vKiogSW50ZXJmYWNlIG9mIGluZm9ybWF0aW9uIGFib3V0IGEgVXJpICAqL1xuZXhwb3J0IGludGVyZmFjZSBVcmlJbmZvIHtcbiAgICBzb3VyY2U6IHN0cmluZztcbiAgICBwcm90b2NvbDogc3RyaW5nO1xuICAgIGF1dGhvcml0eTogc3RyaW5nO1xuICAgIHVzZXJJbmZvOiBzdHJpbmc7XG4gICAgdXNlcjogc3RyaW5nO1xuICAgIHBhc3N3b3JkOiBzdHJpbmc7XG4gICAgaG9zdDogc3RyaW5nO1xuICAgIHBvcnQ6IHN0cmluZztcbiAgICByZWxhdGl2ZTogc3RyaW5nO1xuICAgIHBhdGg6IHN0cmluZztcbiAgICBkaXJlY3Rvcnk6IHN0cmluZztcbiAgICBmaWxlOiBzdHJpbmc7XG4gICAgcXVlcnk6IHN0cmluZztcbiAgICBhbmNob3I6IHN0cmluZztcbn1cbiJdfQ==