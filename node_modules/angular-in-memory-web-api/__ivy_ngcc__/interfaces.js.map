{"version":3,"file":"interfaces.js","sources":["interfaces.ts"],"names":[],"mappings":";;;;;;;;;;AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,eAAe,CAAC;AAU3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AAEK,IAFL;AAA+B,IAiB/B,CAAC;AACD,IADA,wBAAC;AAAD,CAAC,AAjBD,IAiBC;AACD;AACA;AACA;AACA,EAAE;AACF;AAEK,IAFL;AAAuC,IAmDvC,CAAC;AACD,IADA,gCAAC;AAAD,CAAC,AAnDD,IAmDC;AACD;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AAEF;AAAyD,IACvD,+BAAY,MAAsC;AACpD,QADc,uBAAA,EAAA,WAAsC;AACpD,QAAI,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE;AACxB,YAAM,kBAAkB;AACxB,YAAM,mBAAmB,EAAE,KAAK;AAChC,YAAM,iBAAiB,EAAE,KAAK;AAAE,YAC1B,KAAK,EAAE,GAAG;AAAE,YACZ,SAAS,EAAE,KAAK;AAAE,YAClB,kBAAkB,EAAE,KAAK;AAAE,YAC3B,OAAO,EAAE,IAAI;AAAE,YACf,OAAO,EAAE,KAAK;AAAE,YAChB,MAAM,EAAE,IAAI;AAAE,YACd,MAAM,EAAE,KAAK;AAAE,YACf,OAAO,EAAE,SAAS;AAAE,YACpB,IAAI,EAAE,SAAS;AAAE,YACjB,QAAQ,EAAE,SAAS,CAAC,+DAA+D;AACzF,SAAK,EAAE,MAAM,CAAC,CAAC;AACf,IAAE,CAAC;AACH,IAlBa,qBAAqB,wBADjC,UAAU,EAAE,rBACL,kCACc,yBAAyB;AAAG,OADrC,qBAAqB,CAkBjC;;;;;mFACD;AACA,IAFA,4BAAC;AAED,CAFC,AAlBD,IAkBC;AACD,SAnBa,qBAAqB;AAoBlC,gDAAgD;AAChD,MAAM,UAAU,QAAQ,CAAC,GAAW;AAAI,IACtC,mFAAmF;AACrF,IAAE,2CAA2C;AAC7C,IAAE,IAAM,SAAS,GAAG,kMAAkM,CAAC;AACvN,IAAE,IAAM,CAAC,GAAG,SAAS,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,IAAE,IAAM,GAAG,GAAY;AACvB,QAAI,MAAM,EAAE,EAAE;AACd,QAAI,QAAQ,EAAE,EAAE;AAChB,QAAI,SAAS,EAAE,EAAE;AACjB,QAAI,QAAQ,EAAE,EAAE;AAChB,QAAI,IAAI,EAAE,EAAE;AACZ,QAAI,QAAQ,EAAE,EAAE;AAChB,QAAI,IAAI,EAAE,EAAE;AACZ,QAAI,IAAI,EAAE,EAAE;AACZ,QAAI,QAAQ,EAAE,EAAE;AAChB,QAAI,IAAI,EAAE,EAAE;AACZ,QAAI,SAAS,EAAE,EAAE;AACjB,QAAI,IAAI,EAAE,EAAE;AACZ,QAAI,KAAK,EAAE,EAAE;AACb,QAAI,MAAM,EAAE,EAAE;AACd,KAAG,CAAC;AACJ,IAAE,IAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAChC,IAAE,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;AACtB,IACE,OAAO,CAAC,EAAE,EAAE;AAAE,QAAA,GAAG,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;AAAC,KAAC;AAC5C,IAAE,OAAO,GAAG,CAAC;AACb,CAAC;AA4BD,MAAM,UAAU,mBAAmB,CAAC,IAAY;AAChD,IAAE,OAAO,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;AACjC,CAAC;AACD","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\n/**\n *  Minimum definition needed by base class\n */\nexport interface HeadersCore {\n  set(name: string, value: string): void | any;\n}\n\n/**\n* Interface for a class that creates an in-memory database\n*\n* Its `createDb` method creates a hash of named collections that represents the database\n*\n* For maximum flexibility, the service may define HTTP method overrides.\n* Such methods must match the spelling of an HTTP method in lower case (e.g, \"get\").\n* If a request has a matching method, it will be called as in\n* `get(info: requestInfo, db: {})` where `db` is the database object described above.\n*/\nexport abstract class InMemoryDbService {\n  /**\n  * Creates an in-memory \"database\" hash whose keys are collection names\n  * and whose values are arrays of collection objects to return or update.\n  *\n  * returns Observable of the database because could have to create it asynchronously.\n  *\n  * This method must be safe to call repeatedly.\n  * Each time it should return a new object with new arrays containing new item objects.\n  * This condition allows the in-memory backend service to mutate the collections\n  * and their items without touching the original source data.\n  *\n  * The in-mem backend service calls this method without a value the first time.\n  * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.\n  * Your InMemoryDbService can adjust its behavior accordingly.\n  */\n  abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;\n}\n\n/**\n* Interface for InMemoryBackend configuration options\n*/\nexport abstract class InMemoryBackendConfigArgs {\n  /**\n   * The base path to the api, e.g, 'api/'.\n   * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.\n   */\n  apiBase?: string;\n  /**\n   * false (default) if search match should be case insensitive\n   */\n  caseSensitiveSearch?: boolean;\n  /**\n   * false (default) put content directly inside the response body.\n   * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.\n   */\n  dataEncapsulation?: boolean;\n  /**\n   * delay (in ms) to simulate latency\n   */\n  delay?: number;\n  /**\n   * false (default) should 204 when object-to-delete not found; true: 404\n   */\n  delete404?: boolean;\n  /**\n   * host for this service, e.g., 'localhost'\n   */\n  host?: string;\n  /**\n   * false (default) should pass unrecognized request URL through to original backend; true: 404\n   */\n  passThruUnknownUrl?: boolean;\n  /**\n   * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n   */\n  post204?: boolean;\n  /**\n  * false (default) should NOT update existing item with POST. false: OK to update.\n  */\n  post409?: boolean;\n  /**\n  * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n  */\n  put204?: boolean;\n  /**\n   * false (default) if item not found, create as new item; false: should 404.\n   */\n  put404?: boolean;\n  /**\n   * root path _before_ any API call, e.g., ''\n   */\n  rootPath?: string;\n}\n\n/////////////////////////////////\n/**\n*  InMemoryBackendService configuration options\n*  Usage:\n*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})\n*\n*  or if providing separately:\n*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),\n*/\n@Injectable()\nexport class InMemoryBackendConfig implements InMemoryBackendConfigArgs {\n  constructor(config: InMemoryBackendConfigArgs = {}) {\n    Object.assign(this, {\n      // default config:\n      caseSensitiveSearch: false,\n      dataEncapsulation: false, // do NOT wrap content within an object with a `data` property\n      delay: 500, // simulate latency by delaying response\n      delete404: false, // don't complain if can't find entity to delete\n      passThruUnknownUrl: false, // 404 if can't process URL\n      post204: true, // don't return the item after a POST\n      post409: false, // don't update existing item with that ID\n      put204: true,  // don't return the item after a PUT\n      put404: false, // create new item if PUT item with that ID not found\n      apiBase: undefined, // assumed to be the first path segment\n      host: undefined,    // default value is actually set in InMemoryBackendService ctor\n      rootPath: undefined // default value is actually set in InMemoryBackendService ctor\n    }, config);\n  }\n}\n\n/** Return information (UriInfo) about a URI  */\nexport function parseUri(str: string): UriInfo {\n  // Adapted from parseuri package - http://blog.stevenlevithan.com/archives/parseuri\n  // tslint:disable-next-line:max-line-length\n  const URL_REGEX = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n  const m = URL_REGEX.exec(str);\n  const uri: UriInfo = {\n    source: '',\n    protocol: '',\n    authority: '',\n    userInfo: '',\n    user: '',\n    password: '',\n    host: '',\n    port: '',\n    relative: '',\n    path: '',\n    directory: '',\n    file: '',\n    query: '',\n    anchor: ''\n  };\n  const keys = Object.keys(uri);\n  let i = keys.length;\n\n  while (i--) { uri[keys[i]] = m[i] || ''; }\n  return uri;\n}\n\n/**\n *\n * Interface for the result of the `parseRequestUrl` method:\n *   Given URL \"http://localhost:8080/api/customers/42?foo=1 the default implementation returns\n *     base: 'api/'\n *     collectionName: 'customers'\n *     id: '42'\n *     query: this.createQuery('foo=1')\n *     resourceUrl: 'http://localhost/api/customers/'\n */\nexport interface ParsedRequestUrl {\n  apiBase: string;           // the slash-terminated \"base\" for api requests (e.g. `api/`)\n  collectionName: string; // the name of the collection of data items (e.g.,`customers`)\n  id: string;             // the (optional) id of the item in the collection (e.g., `42`)\n  query: Map<string, string[]>; // the query parameters;\n  resourceUrl: string;    // the effective URL for the resource (e.g., 'http://localhost/api/customers/')\n}\n\nexport interface PassThruBackend {\n  /**\n   * Handle an HTTP request and return an Observable of HTTP response\n   * Both the request type and the response type are determined by the supporting HTTP library.\n   */\n  handle(req: any): Observable<any>;\n}\n\nexport function removeTrailingSlash(path: string) {\n  return path.replace(/\\/$/, '');\n}\n\n/**\n *  Minimum definition needed by base class\n */\nexport interface RequestCore {\n  url: string; // request URL\n  urlWithParams?: string; // request URL with query parameters added by `HttpParams`\n}\n\n/**\n* Interface for object w/ info about the current request url\n* extracted from an Http Request.\n* Also holds utility methods and configuration data from this service\n*/\nexport interface RequestInfo {\n  req: RequestCore; // concrete type depends upon the Http library\n  apiBase: string;\n  collectionName: string;\n  collection: any;\n  headers: HeadersCore;\n  method: string;\n  id: any;\n  query: Map<string, string[]>;\n  resourceUrl: string;\n  url: string; // request URL\n  utils: RequestInfoUtilities;\n}\n\n/**\n * Interface for utility methods from this service instance.\n * Useful within an HTTP method override\n */\nexport interface RequestInfoUtilities {\n  /**\n   * Create a cold response Observable from a factory for ResponseOptions\n   * the same way that the in-mem backend service does.\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\n   * @param withDelay - if true (default), add simulated latency delay from configuration\n   */\n  createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;\n\n  /**\n   * Find first instance of item in collection by `item.id`\n   * @param collection\n   * @param id\n   */\n  findById<T extends { id: any }>(collection: T[], id: any): T;\n\n  /** return the current, active configuration which is a blend of defaults and overrides */\n  getConfig(): InMemoryBackendConfigArgs;\n\n  /** Get the in-mem service's copy of the \"database\" */\n  getDb(): {};\n\n  /** Get JSON body from the request object */\n  getJsonBody(req: any): any;\n\n  /** Get location info from a url, even on server where `document` is not defined */\n  getLocation(url: string): UriInfo;\n\n  /** Get (or create) the \"real\" backend */\n  getPassThruBackend(): PassThruBackend;\n\n  /**\n   * return true if can determine that the collection's `item.id` is a number\n   * */\n  isCollectionIdNumeric<T extends { id: any }>(collection: T[], collectionName: string): boolean;\n\n  /**\n   * Parses the request URL into a `ParsedRequestUrl` object.\n   * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n   */\n  parseRequestUrl(url: string): ParsedRequestUrl;\n}\n\n/**\n * Provide a `responseInterceptor` method of this type in your `inMemDbService` to\n * morph the response options created in the `collectionHandler`.\n */\nexport type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;\n\nexport interface ResponseOptions {\n  /**\n   * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.\n   */\n  body?: string | Object | ArrayBuffer | Blob;\n\n  /**\n   * Response headers\n   */\n  headers?: HeadersCore;\n\n  /**\n   * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}\n   * associated with the response.\n   */\n  status?: number;\n\n  /**\n   * Status text for the status code\n   */\n  statusText?: string;\n  /**\n   * request url\n   */\n  url?: string;\n}\n\n/** Interface of information about a Uri  */\nexport interface UriInfo {\n  source: string;\n  protocol: string;\n  authority: string;\n  userInfo: string;\n  user: string;\n  password: string;\n  host: string;\n  port: string;\n  relative: string;\n  path: string;\n  directory: string;\n  file: string;\n  query: string;\n  anchor: string;\n}\n"]}